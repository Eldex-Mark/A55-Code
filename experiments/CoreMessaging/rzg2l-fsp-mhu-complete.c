/* Configuration Files generated by FSP */
/* hal_data.h is auto-generated in src/smc_gen/general/ after configuring in FSP */

/* ra_cfg/fsp_cfg/r_mhu_cfg.h */
#ifndef R_MHU_CFG_H_
#define R_MHU_CFG_H_

#define MHU_CFG_PARAM_CHECKING_ENABLE (1)
#define MHU_CFG_INT_PRIORITY         (2)

#endif /* R_MHU_CFG_H_ */

/* Cortex-M33 Side (CM33) */
/* src/cortex_m33/mhu_cm33.c */

#include "hal_data.h"           // Generated by FSP configurator
#include "r_mhu_ns_api.h"
#include "r_ioport.h"

/* MHU channel definitions */
#define MHU_CH0_TX     (0)    // Channel for M33 -> A55
#define MHU_CH0_RX     (1)    // Channel for A55 -> M33
#define MSG_SIZE       (64)
#define TIMEOUT        (1000)

static uint32_t g_message_buffer[MSG_SIZE];
static volatile bool g_message_received = false;

void mhu_callback_m33(mhu_callback_args_t *p_args)
{
    if (NULL != p_args)
    {
        switch (p_args->event)
        {
            case MHU_EVENT_RX_COMPLETE:
                g_message_received = true;
                break;
            default:
                break;
        }
    }
}

/* Cortex-A55 Side (Linux) */
/* drivers/mhu/rzg2l_mhu.c */
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/interrupt.h>
#include <linux/io.h>

#define MHU_CH0_TX     (1)    // Channel for A55 -> M33
#define MHU_CH0_RX     (0)    // Channel for M33 -> A55

struct rzg2l_mhu {
    void __iomem *base;
    int irq;
    struct device *dev;
};

/* Linux driver setup */
static int rzg2l_mhu_probe(struct platform_device *pdev)
{
    struct rzg2l_mhu *mhu;
    struct resource *res;
    int ret;

    mhu = devm_kzalloc(&pdev->dev, sizeof(*mhu), GFP_KERNEL);
    if (!mhu)
        return -ENOMEM;

    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    mhu->base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(mhu->base))
        return PTR_ERR(mhu->base);

    mhu->irq = platform_get_irq(pdev, 0);
    if (mhu->irq < 0)
        return mhu->irq;

    mhu->dev = &pdev->dev;
    platform_set_drvdata(pdev, mhu);

    return 0;
}

/* Device Tree Example */
/* arch/arm64/boot/dts/renesas/r9a07g044l.dtsi */
mhu: mhu@11030000 {
    compatible = "renesas,rzg2l-mhu";
    reg = <0x0 0x11030000 0x0 0x1000>;
    interrupts = <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
                 <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
    #mbox-cells = <1>;
    status = "okay";
};

/* FSP Configuration for CM33 */
/* configuration.xml */
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<v1:pinSettings xmlns:v1="http://www.tasking.com/schema/pinsettings/v1.1">
    <v1:modeSettings>
        <v1:modeSet name="MHU">
            <v1:peripheral name="MHU" mode="Enabled"/>
        </v1:modeSet>
    </v1:modeSettings>
</v1:pinSettings>

/* Example Usage on CM33 */
void example_mhu_cm33(void)
{
    fsp_err_t err;
    
    /* Initialize MHU via FSP configurator generated code */
    err = R_MHU_Open(&g_mhu_ctrl, &g_mhu_cfg);
    if (FSP_SUCCESS != err)
    {
        return;
    }
    
    /* Enable interrupts */
    err = R_MHU_InterruptEnable(&g_mhu_ctrl);
    if (FSP_SUCCESS != err)
    {
        R_MHU_Close(&g_mhu_ctrl);
        return;
    }
    
    /* Send message to A55 */
    uint32_t tx_message[4] = {0x11111111, 0x22222222, 0x33333333, 0x44444444};
    err = R_MHU_Send(&g_mhu_ctrl, tx_message, 4, MHU_CH0_TX, TIMEOUT);
    
    /* Wait for response from A55 */
    while (!g_message_received) {
        /* Could add timeout here */
    }
}
